---
description: Easy
---

# 14. Classical Binary Search

## Description

Given a target integer T and an integer array A sorted in ascending order, find the index i such that A\[i\] == T or return -1 if there is no such index.

**Assumptions**

* There can be duplicate elements in the array, and you can return any of the indices i such that A\[i\] == T.

**Examples**

* A = {1, 2, 3, 4, 5}, T = 3, return 2
* A = {1, 2, 3, 4, 5}, T = 6, return -1
* A = {1, 2, 2, 2, 3, 4}, T = 2, return 1 or 2 or 3

**Corner Cases**

* What if A is null or A is of zero length? We should return -1 in this case.

Once you're strong enough, save the world:



## CART



## Code

```text
public class Solution {
  public int binarySearch(int[] array, int target) {
    if (array == null || array.length == 0 || target < array[0] || target > array[array.length - 1]) {
      return -1;
    }
    int lo = 0;
    int hi = array.length - 1;
    while (lo < hi - 1) {
      int mid = lo + (hi - lo) / 2;
      if (target <= array[mid]) {
        hi = mid;
      } else {
        lo = mid;
      }
    }
    if (array[lo] == target) {
      return lo;
    } else if (array[hi] == target) {
      return hi;
    }
    return -1;
  }
}

```



