---
description: Medium
---

# 19. K Closest In Sorted Array

## Description

Given a target integer T, a non-negative integer K and an integer array A sorted in ascending order, find the K closest numbers to T in A. If there is a tie, the smaller elements are always preferred.

**Assumptions**

* A is not null
* K is guaranteed to be &gt;= 0 and K is guaranteed to be &lt;= A.length

**Return**

* A size K integer array containing the K closest numbers\(not indices\) in A, sorted in ascending order by the difference between the number and T. 

**Examples**

* A = {1, 2, 3}, T = 2, K = 3, return {2, 1, 3} or {2, 3, 1}
* A = {1, 4, 6, 8}, T = 3, K = 3, return {4, 1, 6}

## Code

```text
public class Solution {
  public int[] kClosest(int[] array, int target, int k) {
    if (k == 0) {
     return new int[0];
    }
    int[] res = new int[k];
    int left = closest(array, target);
    //if (left == array.length - 1) {
    //  return Arrays.copyOfRange(array, left - k + 1, left);
    //}
    res[0] = array[left];
    int right = left + 1; // not included right )
    left = left - 1;
    for (int i = 1; i < k; i++) {
      if (left >= 0 && (right >= array.length  || Math.abs(array[right] - target) >= Math.abs(array[left] - target))) {
        res[i] = array[left--];
      } else {
        res[i] = array[right++];
      }
    }
    return res;
  }
  private int closest(int[] array, int target) {
    // return the closest index, smaller
    if (array.length == 1) {
      return 0;
    }
    int lo = 0;
    int hi = array.length - 1;
    while (lo < hi - 1) {
      int mid = lo + (hi - lo) / 2;
      if (array[mid] == target) {
        return mid;
      } else if (target > array[mid]) {
        lo = mid;
      } else {
        hi = mid;
      }
    }
    if (Math.abs(array[lo] - target) <= Math.abs(array[hi] - target)) {
      return lo;
    }
    return hi;
  }
}
/*
1. find ind of closest to target; tc - o(logn)
2. two segment; to left, to right 
*/

```

