# 66. All Valid Permutations Of Parentheses I

Medium

Given N pairs of parentheses “\(\)”, return a list with all the valid permutations.

**Assumptions**

* N &gt; 0

**Examples**

* N = 1, all valid permutations are \["\(\)"\]
* N = 3, all valid permutations are \["\(\(\(\)\)\)", "\(\(\)\(\)\)", "\(\(\)\)\(\)", "\(\)\(\(\)\)", "\(\)\(\)\(\)"\]

```text
public class Solution {
  public List<String> validParentheses(int n) {
    List<String> res = new ArrayList<String>();
    if (n < 1) {
      return res;
    }
    char[] arr = new char[2*n];
    helper(arr, 0, n, n, res);
    return res;
  }
  private void helper(char[] arr, int index, int left, int right, List<String> res) {
    // base case
    if (index == arr.length) {
      res.add(new String(arr));
      return;
    } 
    // 1. add left
    if (left > 0) {
      arr[index] = '(';
      helper(arr, index + 1, left - 1, right, res);      
    }

    // 2. add right
    if (left <= 0 || right > left) {
      arr[index] = ')';
      helper(arr, index + 1, left, right - 1, res);
    }
  }
}
/*
method: dfs
recur tree: level 2n, each level choose l/r, tc: o(2^2n), sc: o(2n)

*/
```

```text
public class Solution {
  public List<String> validParentheses(int n) {
    List<String> res = new ArrayList<String>();
    StringBuilder sb = new StringBuilder();
    helper(n, n, sb, res);
    return res;
  }
  private void helper(int left, int right, StringBuilder sb, List<String> res) {
    if (left == 0 && right == 0) {
      res.add(sb.toString());
      return;
    } // base case
    if (left > 0) {
      helper(left-1, right, sb.append('('), res);
      sb.deleteCharAt(sb.length()-1);
    }
    if (right > 0 && left < right) {
      helper(left, right-1, sb.append(')'), res);
      sb.deleteCharAt(sb.length()-1);
    }
  }
} // TC: o(2^{2n}); SC: o(n)

```

