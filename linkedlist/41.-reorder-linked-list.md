# 41. ReOrder Linked List

Hard

Reorder the given singly-linked list N1 -&gt; N2 -&gt; N3 -&gt; N4 -&gt; … -&gt; Nn -&gt; null to be N1- &gt; Nn -&gt; N2 -&gt; Nn-1 -&gt; N3 -&gt; Nn-2 -&gt; … -&gt; null

**Examples**

* L = null, is reordered to null
* L = 1 -&gt; null, is reordered to 1 -&gt; null
* L = 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; null, is reordered to 1 -&gt; 4 -&gt; 2 -&gt; 3 -&gt; null
* L = 1 -&gt; 2 -&gt; 3 -&gt; null, is reordered to 1 -&gt; 3 -&gt; 2 -&gt; null

```text
/**
 * class ListNode {
 *   public int value;
 *   public ListNode next;
 *   public ListNode(int value) {
 *     this.value = value;
 *     next = null;
 *   }
 * }
 */
public class Solution {
  public ListNode reorder(ListNode head) {
    if (head == null || head.next == null) {
      return head;
    }
    // find mid o(n)
    ListNode mid = findMid(head);
    // reverse the latter part o(n)
    ListNode two = mid.next;
    ListNode one = head;
    mid.next = null;
    two = reverse(two);
    // combine two linkedlist
    return combine(one, two);
  }
  private ListNode combine(ListNode one, ListNode two) {
    ListNode dum = new ListNode(0);    
    ListNode cur = dum;
    while (one != null && two != null) {
      cur.next = one;
      cur = cur.next;
      one = one.next;
      cur.next = two;
      two = two.next;
      cur = cur.next;
    }
    if (one != null) {
      cur.next = one;
    }
    return dum.next;
  }
  private ListNode reverse(ListNode head) {
    if (head == null || head.next == null) {
      return head;
    }
    ListNode newHead = reverse(head.next);
    head.next.next = head;
    head.next = null;
    return newHead;    
  }
  private ListNode findMid(ListNode head) {
    if (head == null || head.next == null) {
      return head;
    }
    ListNode s = head;
    ListNode f = head.next;
    while (f.next != null && f.next.next != null) {
      s = s.next;
      f = f.next.next;
    } 
    return s;   
  }
}

```

